<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="./assets/ui/mini-logo.webp">
  <title>GFRIEND Music Game : Mix Mode</title>

  <style>
  :root{
    /* ✅ 키컬러 유지 */
    --key:#00ABC0;
    --accent:#5F4B8B;

    /* ✅ 베이스 톤 */
    --bg:#f6f8fb;
    --card:#ffffff;
    --text:#0f172a;
    --muted:#475569;
    --line:rgba(15,23,42,0.10);

    --ok:#16a34a;
    --bad:#dc2626;

    --radius:22px;
    --w:min(980px, 100%);
    --pad:clamp(16px, 2.3vw, 28px);
    --gap:clamp(12px, 1.7vw, 18px);

    --title:clamp(18px, 2.4vw, 26px);
    --textS:clamp(13px, 1.55vw, 16px);
    --big:clamp(16px, 2.2vw, 22px);
    --small:clamp(12px, 1.4vw, 14px);
    --inputH:clamp(40px, 4.4vw, 48px);

    --shadow: 0 14px 28px rgba(2,6,23,0.10);
    --shadow2: 0 8px 16px rgba(2,6,23,0.08);
  }

  html, body { height:100%; }
  *{ box-sizing:border-box; }

  body{
    margin:0;
    font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:var(--bg);
    color:var(--text);
    display:grid;
    place-items:center;
    padding:16px;
  }

  /* ✅ 키컬러 조명 */
  body::before{
    content:"";
    position:fixed;
    inset:0;
    pointer-events:none;
    background:
      radial-gradient(900px 520px at 12% -10%,
        rgba(0,171,192,0.45),
        rgba(0,171,192,0) 60%),
      radial-gradient(700px 520px at 92% 8%,
        rgba(95,75,139,0.28),
        rgba(95,75,139,0) 55%);
    z-index:-1;
  }

  .wrap{
    width:var(--w);
    display:grid;
    gap:var(--gap);
  }
    .panel{
      background:var(--card);
      border:1px solid rgba(0,171,192,0.35);
      border-radius:var(--radius);
      padding:var(--pad);
      box-shadow:var(--shadow2);
    }

    .now{
      display:grid;
      place-items:center;
      font-weight:950;
      font-size:var(--title);
      min-height:clamp(56px, 8vw, 86px);
      letter-spacing:-0.2px;
      text-align:center;
      border:2px solid rgba(0,171,192,0.70);
      background: rgba(0,171,192,0.01);
    }

  .screen{ display:none; width:100%; }
  .screen.on{
    display:grid;
    gap:var(--gap);
  }

  /* 시작 화면 */
  .startBox{
    display:grid;
    gap:16px;
    place-items:center;
    min-height:clamp(320px, 40vw, 420px);
    text-align:center;
  }

  .bigText{
    font-size:clamp(18px, 2.6vw, 28px);
    font-weight:950;
    letter-spacing:-0.3px;
  }

  .smallText{
    font-size:var(--textS);
    font-weight:850;
    text-align:center;
    line-height:1.55;
    color:var(--muted);
  }

  .groupPick{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:center;
  }

  .groupBtn{
    border:1px solid var(--line);
    border-radius:16px;
    padding:12px 14px;
    font-weight:950;
    cursor:pointer;
    background:#fff;
    color:var(--text);
    font-size:var(--textS);
    transition: transform 140ms ease, box-shadow 140ms ease, background 140ms ease;
    box-shadow: 0 10px 18px rgba(2,6,23,0.06);
  }

  .groupBtn:hover{
    transform: translateY(-1px);
    box-shadow: 0 14px 22px rgba(2,6,23,0.10);
  }

  .groupBtn.on{
    background: rgba(0,171,192,0.10);
    border-color: rgba(0,171,192,0.45);
    box-shadow: 0 14px 22px rgba(0,171,192,0.10);
  }

  .startBtn{
    width:min(280px, 82%);
    height:clamp(54px, 6.8vw, 62px);
    border:0;
    border-radius:18px;
    background: linear-gradient(180deg, #6d58a0, var(--accent));
    color:#fff;
    font-weight:950;
    font-size:clamp(16px, 2vw, 18px);
    cursor:pointer;
    box-shadow: 0 16px 30px rgba(95,75,139,0.28);
    transition: transform 140ms ease, box-shadow 140ms ease;
  }

  .startBtn:hover{
    transform: translateY(-2px);
    box-shadow: 0 20px 36px rgba(95,75,139,0.35);
  }

  .startBtn:disabled{
    opacity:0.55;
    cursor:not-allowed;
    box-shadow:none;
  }

  /* 메인으로 버튼(스타트 화면) */
  #homeBtn.startBtn{
    background:#fff;
    color:var(--text);
    border:1px solid var(--line);
    box-shadow: 0 10px 18px rgba(2,6,23,0.08);
  }

  /* 게임 화면 */
  .main{
    display:grid;
    gap:clamp(12px, 2vw, 18px);
    place-items:center;
    min-height:clamp(320px, 55vw, 520px);
  }

  .grid3{
    width:100%;
    display:grid;
    grid-template-columns:repeat(3, minmax(0, 1fr));
    gap:var(--gap);
    align-items:stretch;
  }

  @media (max-width: 820px){
    .grid3{ grid-template-columns:1fr; }
  }

  .songCard{
    display:grid;
    gap:12px;
    border:1px solid var(--line);
    background:#fff;
    border-radius:20px;
    padding:16px;
    width:100%;
    overflow:hidden;
    min-height:clamp(150px, 20vw, 170px);
    box-shadow: 0 12px 24px rgba(2,6,23,0.08);
  }

  .songTop{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    flex-wrap:wrap;
    width:100%;
  }

  .songIdx{
    font-weight:950;
    font-size:var(--textS);
    border:1px solid var(--line);
    border-radius:999px;
    padding:8px 12px;
    background:#fff;
    white-space:nowrap;
    box-shadow: 0 10px 18px rgba(2,6,23,0.06);
  }

  .songState{
    font-weight:950;
    font-size:var(--small);
    padding:8px 12px;
    border-radius:999px;
    border:1px dashed rgba(15,23,42,0.18);
    background:#fff;
    white-space:nowrap;
    color:var(--muted);
  }

  .songState.ok{
    border-color: rgba(22,163,74,0.45);
    background: rgba(22,163,74,0.08);
    color: var(--ok);
  }

  .songState.bad{
    border-color: rgba(220,38,38,0.45);
    background: rgba(220,38,38,0.08);
    color: var(--bad);
  }

  .answerInput{
    width:100%;
    height:var(--inputH);
    border:1px solid var(--line);
    border-radius:18px;
    font-size:var(--textS);
    padding:0 14px;
    outline:none;
    text-align:center;
    background:#fff;
    color:var(--text);
    font-weight:850;
    min-width:0;
    transition: box-shadow 140ms ease, border-color 140ms ease;
  }

  .answerInput::placeholder{
    color:#94a3b8;
    font-weight:800;
  }

  .answerInput:focus{
    border-color: rgba(0,171,192,0.45);
    box-shadow: 0 0 0 4px rgba(0,171,192,0.18);
  }

  .answerInput:disabled{
    background:#f6f6f6;
    color:#64748b;
  }

  .bigBtns{
    display:flex;
    gap:clamp(10px, 2vw, 16px);
    justify-content:center;
    flex-wrap:wrap;
    width:100%;
  }

  .bigBtn{
    width:clamp(160px, 28vw, 220px);
    height:clamp(84px, 12vw, 112px);
    border:0;
    border-radius:20px;
    background: linear-gradient(180deg, #ffffff, #f3f4f6);
    color:var(--text);
    font-weight:950;
    font-size:var(--big);
    cursor:pointer;
    display:grid;
    place-items:center;
    line-height:1.05;
    box-shadow: 0 14px 26px rgba(2,6,23,0.10);
    transition: transform 140ms ease, box-shadow 140ms ease;
    position:relative;
    overflow:hidden;
  }

  /* ✅ 버튼 구분용 상단 포인트 바 */
  #revealBtn::before,
  #replayBtn::before{
    content:"";
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:6px;
    border-radius:20px 20px 0 0;
  }
  
  #revealBtn::before{
    background: rgba(0,171,192,0.85);
  }
  
  #replayBtn::before{
    background: rgba(0,171,192,0.85);
  }


  .bigBtn:hover{
    transform: translateY(-2px);
    box-shadow: 0 18px 34px rgba(2,6,23,0.14);
  }

  .bigBtn:disabled{
    opacity:0.50;
    cursor:not-allowed;
    box-shadow:none;
  }

  .mvArea{
    display:grid;
    place-items:center;
    gap:8px;
  }

  .mvLabel{
    font-size:var(--textS);
    font-weight:950;
    color:var(--muted);
  }

  /* ✅ MV 버튼: 민트 */
  .mvBtn{
    width:clamp(64px, 9vw, 78px);
    height:clamp(34px, 5vw, 42px);
    border:0;
    border-radius:16px;
    background: linear-gradient(180deg, #27c6d8, var(--key));
    color:#fff;
    font-weight:950;
    cursor:pointer;
    font-size:var(--small);
    box-shadow: 0 16px 30px rgba(0,171,192,0.25);
    transition: transform 140ms ease, box-shadow 140ms ease;
  }

  .mvBtn:hover{
    transform: translateY(-2px);
    box-shadow: 0 20px 36px rgba(0,171,192,0.33);
  }

  .mvBtn.off{
    background:#e5e7eb;
    color:var(--text);
    box-shadow:none;
    transform:none;
  }

  .footerRow{
    display:flex;
    align-items:center;
    justify-content:center;
    gap:10px;
    flex-wrap:wrap;
    width:100%;
  }

  .nextBtn{
    width:clamp(170px, 28vw, 240px);
    height:clamp(46px, 6.2vw, 56px);
    border:0;
    border-radius:18px;
    background:
      radial-gradient(120% 140% at 50% 0%,
        rgba(255,255,255,0.25),
        rgba(255,255,255,0) 55%),
      linear-gradient(180deg, #6d58a0, var(--accent));
    color:#fff;
    font-weight:950;
    font-size:var(--textS);
    cursor:pointer;
    box-shadow: 0 16px 30px rgba(95,75,139,0.28);
    transition: transform 140ms ease, box-shadow 140ms ease, filter 140ms ease;
  }

  .nextBtn:hover{
    transform: translateY(-2px);
    box-shadow: 0 20px 36px rgba(95,75,139,0.35);
    filter: brightness(1.03);
  }

  .nextBtn:disabled{
    opacity:0.50;
    cursor:not-allowed;
    box-shadow:none;
  }

  /* ✅ 메시지 칩 */
  .msg{
    width:min(720px, 94%);
    text-align:center;
    font-size:var(--textS);
    font-weight:950;
    min-height:24px;
    white-space:pre-line;
    padding:10px 12px;
    border-radius:16px;
    border:1px dashed rgba(15,23,42,0.18);
    background:#fff;
    color:var(--text);
  }

  .msg.ok{
    border-color: rgba(22,163,74,0.45);
    background: rgba(22,163,74,0.08);
    color: var(--ok);
  }

  .msg.bad{
    border-color: rgba(220,38,38,0.45);
    background: rgba(220,38,38,0.08);
    color: var(--bad);
  }

  /* MV 영역 */
  .mvWrap{
    width:min(980px, 98%);
    overflow:hidden;
    max-height:0;
    opacity:0;
    transform:translateY(-6px);
    transition:max-height 260ms ease, opacity 220ms ease, transform 220ms ease;
  }

  .mvWrap.on{
    max-height:1400px;
    opacity:1;
    transform:translateY(0);
  }

  .playerBox{
    border:1px solid rgba(15,23,42,0.14);
    border-radius:18px;
    background:#000;
    padding:12px;
    display:grid;
    gap:12px;
    box-shadow: var(--shadow);
    overflow:hidden;
  }

  .ytBox{
    width:100%;
    display:grid;
    grid-template-columns:repeat(3, minmax(0, 1fr));
    gap:10px;
  }

  @media (max-width: 820px){
    .ytBox{ grid-template-columns:1fr; }
  }

  .ytItem{
    display:none;
    gap:6px;
  }

  .ytItem.on{
    display:grid;
  }

  .ytTitle{
    color:#fff;
    font-weight:900;
    font-size:var(--small);
    opacity:0.9;
    text-align:left;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }

  .ratio{
    position:relative;
    width:100%;
    aspect-ratio:16/9;
    border-radius:14px;
    overflow:hidden;
    background:#000;
  }

  .ytFrame{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
  }

  @media (max-width: 520px){
    .groupPick{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:10px;
      width:min(360px, 92%);
      margin:0 auto;
    }

    .groupBtn{
      width:100%;
      padding:12px 0;
      text-align:center;
      border-radius:16px;
    }
  }

  @media (prefers-reduced-motion: reduce){
    .startBtn, .groupBtn, .bigBtn, .nextBtn, .mvBtn{
      transition:none;
    }
  }
</style>
</head>

<body>
  <div class="wrap">

    <!-- START SCREEN -->
    <div id="startScreen" class="screen on">
      <div class="panel now">
        <div>믹스 모드</div>
      </div>

      <div class="panel startBox">
        <div class="bigText">게임 설명</div>
        <div class="smallText">
          동시에 재생되는 노래 3개의 제목을 맞추면 됩니다<br />
          범위를 선택한 뒤 게임 시작을 누르세요<br />
          Youtube iframe 정책에 따라 PC에서만 플레이할 수 있습니다 (모바일 환경 불가)
        </div>

        <div class="bigText">입력 가이드</div>
        <div class="smallText">
          대소문자, 띄어쓰기 상관없습니다<br />
          영어 제목을 한글로 적어도 됩니다 (ex. LOL -> 롤)<br />
          일부 곡은 줄임말이 있습니다(ex. 오우, 지만갑, 우다계)
        </div>

        <div class="bigText">범위를 선택하세요</div>

        <div id="groupPick" class="groupPick" aria-label="group pick">
          <button type="button" class="groupBtn on" data-key="gfriend">GFRIEND</button>
          <button type="button" class="groupBtn" data-key="yerin">YERIN</button>
          <button type="button" class="groupBtn" data-key="yuju">YUJU</button>
          <button type="button" class="groupBtn" data-key="viviz">VIVIZ</button>
        </div>

        <button id="startBtn" class="startBtn">게임 시작</button>
        <button id="homeBtn" class="startBtn">메인으로</button>

        <div id="msgStart" class="msg info"></div>
      </div>
    </div>

    <!-- GAME SCREEN -->
    <div id="gameScreen" class="screen">
      <div class="panel now">
        <div>Now Playing</div>
      </div>

      <div class="panel main">

        <div class="grid3" aria-label="answers">
          <div class="songCard">
            <div class="songTop">
              <div class="songIdx">정답 1</div>
              <div id="state0" class="songState">대기</div>
            </div>
            <input id="ans0" class="answerInput" placeholder="입력하세요" autocomplete="off" />
          </div>

          <div class="songCard">
            <div class="songTop">
              <div class="songIdx">정답 2</div>
              <div id="state1" class="songState">대기</div>
            </div>
            <input id="ans1" class="answerInput" placeholder="입력하세요" autocomplete="off" />
          </div>

          <div class="songCard">
            <div class="songTop">
              <div class="songIdx">정답 3</div>
              <div id="state2" class="songState">대기</div>
            </div>
            <input id="ans2" class="answerInput" placeholder="입력하세요" autocomplete="off" />
          </div>
        </div>

        <!-- 1 엔터 정답공개 -->
        <div class="bigBtns">
          <button id="enterBtn" class="bigBtn">Enter</button>
          <button id="revealBtn" class="bigBtn">정답 공개</button>
        </div>

        <!-- 2 MV 온오프 -->
        <div class="mvArea">
          <div class="mvLabel">M V</div>
          <button id="mvBtn" class="mvBtn">on</button>
        </div>

        <!-- 3 다음 -->
        <div class="footerRow">
          <button id="nextBtn" class="nextBtn" disabled>다음</button>
        </div>

        <!-- 4 MV 공간 (펼쳐짐) -->
        <div id="mvWrap" class="mvWrap" aria-label="mv area">
          <div class="playerBox">
            <div class="ytBox">
              <div id="ytItem0" class="ytItem">
                <div id="ytTitle0" class="ytTitle"></div>
                <div class="ratio">
                  <div id="player0" class="ytFrame"></div>
                </div>
              </div>

              <div id="ytItem1" class="ytItem">
                <div id="ytTitle1" class="ytTitle"></div>
                <div class="ratio">
                  <div id="player1" class="ytFrame"></div>
                </div>
              </div>

              <div id="ytItem2" class="ytItem">
                <div id="ytTitle2" class="ytTitle"></div>
                <div class="ratio">
                  <div id="player2" class="ytFrame"></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div id="msg" class="msg info"></div>

        <!-- 5 메인으로 -->
        <div class="footerRow">
          <button id="homeBtnGame" class="nextBtn">메인으로</button>
        </div>

      </div>
    </div>

  </div>

  <script>
    const STORAGE_BLOCK = "gfriend_blocked_videoids_mix_v2"

    const BLOCK_TTL_1 = 7 * 24 * 60 * 60 * 1000
    const BLOCK_TTL_2 = 30 * 24 * 60 * 60 * 1000

    const GROUPS = {
      gfriend: { label: "GFRIEND", path: "./assets/songs/gfriend.json" },
      yerin:  { label: "YERIN",  path: "./assets/songs/yerin.json"  },
      yuju:   { label: "YUJU",   path: "./assets/songs/yuju.json"   },
      viviz:  { label: "VIVIZ",  path: "./assets/songs/viviz.json"  },
    }

    const el = {
      startScreen: document.getElementById("startScreen"),
      gameScreen: document.getElementById("gameScreen"),

      startBtn: document.getElementById("startBtn"),
      homeBtn: document.getElementById("homeBtn"),
      msgStart: document.getElementById("msgStart"),

      ans0: document.getElementById("ans0"),
      ans1: document.getElementById("ans1"),
      ans2: document.getElementById("ans2"),

      state0: document.getElementById("state0"),
      state1: document.getElementById("state1"),
      state2: document.getElementById("state2"),

      enterBtn: document.getElementById("enterBtn"),
      revealBtn: document.getElementById("revealBtn"),
      mvBtn: document.getElementById("mvBtn"),
      nextBtn: document.getElementById("nextBtn"),
      homeBtnGame: document.getElementById("homeBtnGame"),

      msg: document.getElementById("msg"),

      mvWrap: document.getElementById("mvWrap"),
      ytItem0: document.getElementById("ytItem0"),
      ytItem1: document.getElementById("ytItem1"),
      ytItem2: document.getElementById("ytItem2"),
      ytTitle0: document.getElementById("ytTitle0"),
      ytTitle1: document.getElementById("ytTitle1"),
      ytTitle2: document.getElementById("ytTitle2"),
    }

    function showScreen(which){
      el.startScreen.className = "screen"
      el.gameScreen.className = "screen"
      which.className = "screen on"
    }

    function setMsg(text, kind){
      if(el.msg){
        el.msg.className = "msg " + kind
        el.msg.textContent = text
      }
      if(el.msgStart){
        el.msgStart.className = "msg " + kind
        el.msgStart.textContent = text
      }
    }

    function uniq(arr){
      return Array.from(new Set((arr || []).filter(Boolean)))
    }

    function shuffle(a){
      const b = [...a]
      for(let i=b.length-1;i>0;i--){
        const j = Math.floor(Math.random() * (i+1))
        ;[b[i], b[j]] = [b[j], b[i]]
      }
      return b
    }

    function delay(ms){
      return new Promise(r => setTimeout(r, ms))
    }

    function normalize(s){
      return String(s || "")
        .toLowerCase()
        .replace(/\s+/g, "")
        .replace(/[^0-9a-z가-힣]/g, "")
    }

    function nowMs(){ return Date.now() }

    function isExpired(entry){
      return !entry || typeof entry.until !== "number" || entry.until <= nowMs()
    }

    function cleanBlocked(obj){
      const out = {}
      for(const [vid, entry] of Object.entries(obj || {})){
        if(!isExpired(entry)) out[vid] = entry
      }
      return out
    }

    function loadBlocked(){
      try{
        const raw = localStorage.getItem(STORAGE_BLOCK)
        if(!raw) return {}
        const obj = JSON.parse(raw)
        if(!obj || typeof obj !== "object") return {}
        return cleanBlocked(obj)
      } catch {
        return {}
      }
    }

    function saveBlocked(obj){
      try{
        const cleaned = cleanBlocked(obj)
        localStorage.setItem(STORAGE_BLOCK, JSON.stringify(cleaned))
      } catch {}
    }

    let blocked = loadBlocked()
    saveBlocked(blocked)

    function isBlockedVideoId(videoId){
      const entry = blocked[videoId]
      if(!entry) return false
      if(isExpired(entry)){
        delete blocked[videoId]
        saveBlocked(blocked)
        return false
      }
      return true
    }

    function markBlockedIfEmbed(videoId, code){
      if(!videoId) return
      if(code !== 101 && code !== 150) return

      const prev = blocked[videoId] || { count: 0, until: 0, lastCode: null }

      const nextCount = (typeof prev.count === "number" ? prev.count : 0) + 1
      const ttl = nextCount >= 2 ? BLOCK_TTL_2 : BLOCK_TTL_1

      blocked[videoId] = {
        count: nextCount,
        until: nowMs() + ttl,
        lastCode: code
      }

      saveBlocked(blocked)
    }

    function pickPlayableVideoId(song){
      const ids = uniq(song.videoIds || [])
      for(const id of ids){
        if(!isBlockedVideoId(id)) return id
      }
      return null
    }

    function setState(i, kind, text){
      const target = [el.state0, el.state1, el.state2][i]
      if(!target) return
      target.className = "songState" + (kind ? " " + kind : "")
      target.textContent = text
    }

    let mvOn = true

    function renderMvBtn(){
      if(mvOn){
        el.mvBtn.classList.remove("off")
        el.mvBtn.textContent = "on"
      } else {
        el.mvBtn.classList.add("off")
        el.mvBtn.textContent = "off"
      }
    }

    function showMvWrapIfNeeded(){
      const anyOn =
        el.ytItem0.classList.contains("on") ||
        el.ytItem1.classList.contains("on") ||
        el.ytItem2.classList.contains("on")

      el.mvWrap.className = anyOn ? "mvWrap on" : "mvWrap"
    }

    function applyMvVisibilityPerSong(){
      for(let i=0;i<3;i++){
        const item = [el.ytItem0, el.ytItem1, el.ytItem2][i]
        const canShow = mvOn && solvedByIndex[i] === true
        item.className = canShow ? "ytItem on" : "ytItem"
      }
      showMvWrapIfNeeded()
    }

    function toggleMv(){
      mvOn = !mvOn
      renderMvBtn()
      applyMvVisibilityPerSong()
    }

    let selectedGroupKeys = new Set(["gfriend"])

    let songs = []
    let pool = []

    let currentSongs = []
    let currentVideoIds = []
    let solvedByIndex = [false,false,false]

    let remaining = []
    let slotsSolvedTitle = [null, null, null]

    let players = [null, null, null]
    let readyCount = 0
    let ready = false
    let lastErrorCodes = [null, null, null]

    let actionToken = 0
    const YT_STATE = { PLAYING: 1 }

    function nextToken(){
      actionToken += 1
      return actionToken
    }

    function isCurrentToken(t){
      return t === actionToken
    }

    function resetSetUI(){
      solvedByIndex = [false,false,false]
      slotsSolvedTitle = [null, null, null]

      el.ans0.value = ""
      el.ans1.value = ""
      el.ans2.value = ""

      el.ans0.disabled = false
      el.ans1.disabled = false
      el.ans2.disabled = false

      setState(0, "", "대기")
      setState(1, "", "대기")
      setState(2, "", "대기")

      el.nextBtn.disabled = true

      el.ytTitle0.textContent = ""
      el.ytTitle1.textContent = ""
      el.ytTitle2.textContent = ""

      applyMvVisibilityPerSong()
      setMsg("3곡이 동시에 재생됩니다", "info")
    }

    function stopAll(){
      for(const p of players){
        if(!p) continue
        try{ p.stopVideo() } catch {}
      }
    }

    function pickThreeSongs(){
      if(songs.length < 3) return false
      if(pool.length === 0) pool = shuffle(songs)

      const chosen = []
      const chosenIds = []

      let safety = 0
      while(chosen.length < 3 && safety < songs.length * 4){
        if(pool.length === 0) pool = shuffle(songs)

        const s = pool.shift()
        if(!s){ safety += 1; continue }

        const vid = pickPlayableVideoId(s)
        if(!vid){ safety += 1; continue }

        if(chosenIds.includes(vid)){ safety += 1; continue }
        if(chosen.some(x => x.title === s.title)){ safety += 1; continue }

        chosen.push(s)
        chosenIds.push(vid)
        safety += 1
      }

      if(chosen.length !== 3) return false

      currentSongs = chosen
      currentVideoIds = chosenIds

      remaining = chosen.map((s, idx) => {
        const normSet = new Set((s.answers || []).map(a => normalize(a)))
        return { idx, title: s.title, answersNormalized: normSet }
      })

      return true
    }

    async function waitForPlayingOrError(token, idx, timeoutMs){
      const started = Date.now()
      while(Date.now() - started < timeoutMs){
        if(!isCurrentToken(token)) return { ok:false, reason:"stale" }

        const code = lastErrorCodes[idx]
        if(code !== null) return { ok:false, reason:"error", code }

        let st = null
        try{ st = players[idx].getPlayerState() } catch {}
        if(st === YT_STATE.PLAYING) return { ok:true }

        await delay(80)
      }
      return { ok:false, reason:"timeout" }
    }

    async function playFull(token){
      const baseVol = 35

      for(let i=0;i<3;i++){
        lastErrorCodes[i] = null
        const p = players[i]
        const vid = currentVideoIds[i]

        try{
          p.unMute()
          p.setVolume(baseVol)
          p.loadVideoById({ videoId: vid, startSeconds: 0 })
          p.playVideo()
        } catch {}
      }

      for(let i=0;i<3;i++){
        const r = await waitForPlayingOrError(token, i, 1700)
        if(!isCurrentToken(token)) return { ok:false, reason:"stale" }
        if(!r.ok){
          if(r.reason === "error"){
            markBlockedIfEmbed(currentVideoIds[i], r.code)
          }
          return { ok:false, reason:"fail" }
        }
      }

      return { ok:true }
    }

    async function startNextSet(){
      if(!ready){
        setMsg("플레이어 초기화 중", "bad")
        return
      }
      if(songs.length < 3){
        setMsg("곡 데이터가 3개 이상 필요", "bad")
        return
      }

      const token = nextToken()
      stopAll()
      resetSetUI()

      const ok = pickThreeSongs()
      if(!ok){
        setMsg("재생 가능한 조합이 없음, 임베드 제한이 많을 수 있음", "bad")
        return
      }

      const r = await playFull(token)
      if(!isCurrentToken(token)) return

      if(!r.ok){
        setMsg("재생 실패로 다음 세트로 변경", "bad")
        await delay(220)
        if(isCurrentToken(token)) startNextSet()
        return
      }

      setMsg("정답 3개를 맞혀보세요", "info")
    }

    function isAllSolved(){
      return solvedByIndex.every(Boolean)
    }

    function lockSlot(slotIdx, title){
      const input = [el.ans0, el.ans1, el.ans2][slotIdx]
      if(!input) return

      input.value = title
      input.disabled = true
      slotsSolvedTitle[slotIdx] = title

      setState(slotIdx, "ok", "정답")
    }

    function matchAndConsumeAnswer(raw){
      const vNorm = normalize(raw)
      if(!vNorm) return { ok:false, reason:"empty" }

      for(let i=0;i<remaining.length;i++){
        const it = remaining[i]
        if(it.answersNormalized.has(vNorm)){
          remaining.splice(i, 1)
          return { ok:true, idx: it.idx, title: it.title }
        }
      }
      return { ok:false, reason:"no_match" }
    }

    function updateSolvedSong(idx){
      solvedByIndex[idx] = true

      const titles = [el.ytTitle0, el.ytTitle1, el.ytTitle2]
      titles[idx].textContent = currentSongs[idx].title

      applyMvVisibilityPerSong()
    }

    function submitEnter(){
      if(currentSongs.length !== 3){
        setMsg("세트가 아직 시작되지 않음", "bad")
        return
      }

      const inputs = [el.ans0, el.ans1, el.ans2]

      let anyTried = false
      let anyNewSolved = false

      for(let slot=0; slot<3; slot++){
        const input = inputs[slot]
        if(!input || input.disabled) continue

        const v = input.value
        if(!v || !v.trim()) continue

        anyTried = true

        const r = matchAndConsumeAnswer(v)
        if(r.ok){
          anyNewSolved = true
          lockSlot(slot, r.title)
          updateSolvedSong(r.idx)
        } else {
          setState(slot, "bad", "오답")
        }
      }

      if(!anyTried){
        setMsg("정답을 입력하세요", "bad")
        return
      }

      if(anyNewSolved){
        if(isAllSolved()){
          setMsg("3곡 모두 정답\n다음으로 넘어갈 수 있습니다", "ok")
          el.nextBtn.disabled = false
        } else {
          setMsg("정답 처리 완료", "ok")
        }
        return
      }

      setMsg("정답이 없습니다", "bad")
    }

    function revealAnswers(){
      if(currentSongs.length !== 3){
        setMsg("세트가 아직 시작되지 않음", "bad")
        return
      }

      remaining = []
      solvedByIndex = [true,true,true]

      const slotInputs = [el.ans0, el.ans1, el.ans2]
      const slotStates = [el.state0, el.state1, el.state2]

      const titles = currentSongs.map(s => s.title)
      let tIdx = 0

      for(let slot=0; slot<3; slot++){
        const input = slotInputs[slot]
        if(input.disabled) continue
        input.value = titles[tIdx] || ""
        input.disabled = true
        slotsSolvedTitle[slot] = titles[tIdx] || ""
        slotStates[slot].className = "songState ok"
        slotStates[slot].textContent = "정답"
        tIdx += 1
      }

      el.ytTitle0.textContent = currentSongs[0].title
      el.ytTitle1.textContent = currentSongs[1].title
      el.ytTitle2.textContent = currentSongs[2].title

      applyMvVisibilityPerSong()

      setMsg("정답 공개 완료\n다음으로 넘어갈 수 있습니다", "info")
      el.nextBtn.disabled = false
    }

    async function loadSongsFromSelectedGroups(){
      const keys = Array.from(selectedGroupKeys).filter(k => GROUPS[k])
      if(keys.length === 0){
        setMsg("범위를 1개 이상 선택하세요", "bad")
        return false
      }

      setMsg("데이터 로딩 중", "info")
      el.startBtn.disabled = true

      try{
        const results = await Promise.all(keys.map(async (k) => {
          const g = GROUPS[k]
          const res = await fetch(g.path, { cache: "no-store" })
          if(!res.ok) return { key:k, ok:false, songs:[] }
          const data = await res.json()
          const loaded = (data && data.songs) ? data.songs : []
          const mapped = loaded.map(s => ({
            title: s.title,
            answers: Array.isArray(s.answers) ? uniq(s.answers) : [],
            videoIds: s.videoId ? [s.videoId] : []
          }))
          return { key:k, ok:true, songs:mapped }
        }))

        const merged = []
        for(const r of results){
          merged.push(...(r.songs || []))
        }

        songs = merged
        pool = []

        if(songs.length < 3){
          setMsg("곡 데이터가 3개 이상 필요", "bad")
          el.startBtn.disabled = false
          return false
        }

        setMsg("로딩 완료", "info")
        el.startBtn.disabled = false
        return true
      } catch {
        setMsg("데이터 로딩 실패", "bad")
        el.startBtn.disabled = false
        return false
      }
    }

    async function startGame(){
      const ok = await loadSongsFromSelectedGroups()
      if(!ok) return

      resetSetUI()
      renderMvBtn()
      showScreen(el.gameScreen)

      if(ready){
        await startNextSet()
      } else {
        setMsg("플레이어 초기화 중", "bad")
      }
    }

    function onYouTubeIframeAPIReady(){
      const ids = ["player0", "player1", "player2"]

      for(let i=0;i<3;i++){
        players[i] = new YT.Player(ids[i], {
          videoId: "",
          playerVars: {
            playsinline: 1,
            rel: 0,
            modestbranding: 1,
            controls: 1,
            origin: location.origin
          },
          events: {
            onReady: () => {
              readyCount += 1
              if(readyCount >= 3){
                ready = true
                applyMvVisibilityPerSong()
              }
            },
            onError: (e) => {
              const code = (e && typeof e.data !== "undefined") ? Number(e.data) : -1
              lastErrorCodes[i] = code
              const vid = currentVideoIds[i]
              markBlockedIfEmbed(vid, code)
            }
          }
        })
      }
    }
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady

    window.addEventListener("DOMContentLoaded", () => {
      showScreen(el.startScreen)
      renderMvBtn()
      applyMvVisibilityPerSong()

      const groupPick = document.getElementById("groupPick")
      if(groupPick){
        groupPick.addEventListener("click", (e) => {
          const btn = e.target && e.target.closest ? e.target.closest(".groupBtn") : null
          if(!btn) return

          const key = String(btn.dataset.key || "")
          if(!GROUPS[key]) return

          if(btn.classList.contains("on")){
            if(selectedGroupKeys.size <= 1) return
            btn.classList.remove("on")
            selectedGroupKeys.delete(key)
          } else {
            btn.classList.add("on")
            selectedGroupKeys.add(key)
          }
        })
      }

      el.startBtn.addEventListener("click", () => startGame())

      el.homeBtn.addEventListener("click", () => {
        stopAll()
        location.href = "./index.html"
      })

      el.homeBtnGame.addEventListener("click", () => {
        stopAll()
        location.href = "./index.html"
      })

      el.enterBtn.addEventListener("click", () => submitEnter())
      el.revealBtn.addEventListener("click", () => revealAnswers())
      el.nextBtn.addEventListener("click", () => startNextSet())
      el.mvBtn.addEventListener("click", () => toggleMv())

      const enterHandler = (e) => {
        if(e.key === "Enter"){
          e.preventDefault()
          submitEnter()
        }
      }
      el.ans0.addEventListener("keydown", enterHandler)
      el.ans1.addEventListener("keydown", enterHandler)
      el.ans2.addEventListener("keydown", enterHandler)

      const tag = document.createElement("script")
      tag.src = "https://www.youtube.com/iframe_api"
      document.head.appendChild(tag)
    })
  </script>
</body>
</html>








