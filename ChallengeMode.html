<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="./assets/ui/mini-logo.webp">
  <title>GFRIEND Music Game : Challenge Mode</title>

  <style>
    :root{
      /* âœ… í‚¤ì»¬ëŸ¬ */
      --key:#00ABC0;
      --accent:#5F4B8B;
  
      /* âœ… ë² ì´ìŠ¤ í†¤ */
      --bg:#f6f8fb;
      --card:#ffffff;
      --text:#0f172a;
      --muted:#475569;
      --line:rgba(15,23,42,0.10);
  
      --ok:#16a34a;
      --bad:#dc2626;
  
      --radius:22px;
      --w:min(980px, 100%);
      --pad:clamp(16px, 2.3vw, 28px);
      --gap:clamp(12px, 1.7vw, 18px);
  
      --title:clamp(18px, 2.4vw, 26px);
      --textS:clamp(13px, 1.55vw, 16px);
      --big:clamp(16px, 2.2vw, 22px);
      --small:clamp(12px, 1.4vw, 14px);
      --inputH:clamp(40px, 4.4vw, 48px);
  
      --shadow: 0 14px 28px rgba(2,6,23,0.10);
      --shadow2: 0 8px 16px rgba(2,6,23,0.08);
    }
  
    html, body { height:100%; }
    *{ box-sizing:border-box; }
  
    body{
      margin:0;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
      display:grid;
      place-items:center;
      padding:16px;
    }
  
    /* âœ… í‚¤ì»¬ëŸ¬ëŠ” ë°°ê²½ ë‹¨ìƒ‰ ëŒ€ì‹  ë¬´ë“œ ì¡°ëª… */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(900px 520px at 12% -10%,
          rgba(0,171,192,0.45),
          rgba(0,171,192,0) 60%),
        radial-gradient(700px 520px at 92% 8%,
          rgba(95,75,139,0.28),
          rgba(95,75,139,0) 55%);
      z-index:-1;
    }
  
    .wrap{
      width:var(--w);
      display:grid;
      gap:var(--gap);
    }
  
    .panel{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:var(--pad);
      box-shadow:var(--shadow2);
    }
  
    .now{
      display:grid;
      place-items:center;
      font-weight:950;
      font-size:var(--title);
      min-height:clamp(56px, 8vw, 86px);
      letter-spacing:-0.2px;
      text-align:center;
    }
  
    .main{
      display:grid;
      gap:clamp(12px, 2vw, 18px);
      place-items:center;
      min-height:clamp(360px, 55vw, 560px);
    }
  
    .row{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      font-size:var(--textS);
      text-align:center;
      font-weight:950;
      color:var(--muted);
    }
  
    .livesRow{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      font-size:clamp(22px, 3vw, 28px);
      user-select:none;
    }
  
    .timeRow{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      font-size:var(--big);
      font-weight:950;
      color:var(--text);
      padding:10px 14px;
      border-radius:16px;
      border:1px dashed rgba(15,23,42,0.18);
      background:#fff;
      width:min(320px, 92%);
      text-align:center;
    }
  
    .answerArea{
      display:grid;
      place-items:center;
      gap:10px;
      width:min(560px, 92%);
    }
  
    .answerInput{
      width:100%;
      height:var(--inputH);
      border:1px solid var(--line);
      border-radius:18px;
      font-size:var(--textS);
      padding:0 14px;
      outline:none;
      text-align:center;
      background:#fff;
      color:var(--text);
      font-weight:850;
      transition: box-shadow 140ms ease, border-color 140ms ease;
    }
  
    .answerInput::placeholder{
      color:#94a3b8;
      font-weight:800;
    }
  
    .answerInput:focus{
      border-color: rgba(0,171,192,0.45);
      box-shadow: 0 0 0 4px rgba(0,171,192,0.18);
    }
  
    .enterBtn{
      width:min(220px, 55%);
      height:clamp(40px, 5vw, 46px);
      border:0;
      border-radius:16px;
      background: linear-gradient(180deg, #6d58a0, var(--accent));
      color:#fff;
      font-weight:950;
      cursor:pointer;
      font-size:var(--textS);
      box-shadow: 0 16px 30px rgba(95,75,139,0.25);
      transition: transform 140ms ease, box-shadow 140ms ease;
    }
  
    .enterBtn:hover{
      transform: translateY(-2px);
      box-shadow: 0 20px 36px rgba(95,75,139,0.33);
    }
  
    .enterBtn:active{
      transform: translateY(0) scale(0.99);
    }
  
    .enterBtn:disabled,
    .answerInput:disabled{
      opacity:0.55;
      cursor:not-allowed;
    }
  
    .statRow{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:12px;
      flex-wrap:wrap;
      font-size:var(--textS);
      font-weight:950;
      color:var(--text);
    }
  
    .statRow > div{
      padding:10px 14px;
      border-radius:16px;
      border:1px dashed rgba(15,23,42,0.18);
      background:#fff;
      min-width:140px;
      text-align:center;
    }
  
    .bigBtns{
      display:flex;
      gap:clamp(10px, 2vw, 16px);
      justify-content:center;
      flex-wrap:wrap;
    }
  
    .bigBtn{
      width:clamp(160px, 28vw, 220px);
      height:clamp(84px, 12vw, 112px);
      border:0;
      border-radius:20px;
      background: linear-gradient(180deg, #ffffff, #f3f4f6);
      color:var(--text);
      font-weight:950;
      font-size:var(--big);
      cursor:pointer;
      display:grid;
      place-items:center;
      line-height:1.05;
      box-shadow: 0 14px 26px rgba(2,6,23,0.10);
      transition: transform 140ms ease, box-shadow 140ms ease;
    }
  
    .bigBtn:hover{
      transform: translateY(-2px);
      box-shadow: 0 18px 34px rgba(2,6,23,0.14);
    }
  
    .bigBtn:disabled{
      opacity:0.50;
      cursor:not-allowed;
      box-shadow:none;
    }
  
    .mvArea{
      display:grid;
      place-items:center;
      gap:8px;
    }
  
    .mvLabel{
      font-size:var(--textS);
      font-weight:950;
      color:var(--muted);
    }
  
    /* âœ… ìš”ì²­ì‚¬í•­: MV ë²„íŠ¼ì€ #00ABC0 */
    .mvBtn{
      width:clamp(64px, 9vw, 78px);
      height:clamp(34px, 5vw, 42px);
      border:0;
      border-radius:16px;
      background: linear-gradient(180deg, #27c6d8, var(--key));
      color:#fff;
      font-weight:950;
      cursor:pointer;
      font-size:var(--small);
      box-shadow: 0 16px 30px rgba(0,171,192,0.25);
      transition: transform 140ms ease, box-shadow 140ms ease;
    }
  
    .mvBtn:hover{
      transform: translateY(-2px);
      box-shadow: 0 20px 36px rgba(0,171,192,0.33);
    }
  
    .mvBtn.off{
      background:#e5e7eb;
      color:var(--text);
      box-shadow:none;
      transform:none;
    }
  
    .footerRow{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      width:100%;
    }
  
    .nextBtn{
      width:clamp(170px, 28vw, 240px);
      height:clamp(46px, 6.2vw, 56px);
      border:0;
      border-radius:18px;
      background:
        radial-gradient(120% 140% at 50% 0%,
          rgba(255,255,255,0.25),
          rgba(255,255,255,0) 55%),
        linear-gradient(180deg, #6d58a0, var(--accent));
      color:#fff;
      font-weight:950;
      font-size:var(--textS);
      cursor:pointer;
      box-shadow: 0 16px 30px rgba(95,75,139,0.28);
      transition: transform 140ms ease, box-shadow 140ms ease, filter 140ms ease;
    }
  
    .nextBtn:hover{
      transform: translateY(-2px);
      box-shadow: 0 20px 36px rgba(95,75,139,0.35);
      filter: brightness(1.03);
    }
  
    .nextBtn:disabled{
      opacity:0.50;
      cursor:not-allowed;
      box-shadow:none;
    }
  
    .msg{
      width:min(720px, 94%);
      text-align:center;
      font-size:var(--textS);
      font-weight:950;
      min-height:24px;
      white-space:pre-line;
      padding:10px 12px;
      border-radius:16px;
      border:1px dashed rgba(15,23,42,0.18);
      background:#fff;
      color:var(--text);
    }
  
    .msg.ok{
      border-color: rgba(22,163,74,0.45);
      background: rgba(22,163,74,0.08);
      color: var(--ok);
    }
  
    .msg.bad{
      border-color: rgba(220,38,38,0.45);
      background: rgba(220,38,38,0.08);
      color: var(--bad);
    }
  
    .msg.info{ color:var(--text); }
  
    /* ìœ íŠœë¸Œ ìˆ¨ê¹€/í‘œì‹œ */
    .playerAudioOnly{
      position:absolute;
      left:-9999px;
      top:-9999px;
      width:1px;
      height:1px;
      opacity:0;
      pointer-events:none;
      overflow:hidden;
    }
  
    .playerShow{
      position:static;
      width:min(760px, 96%);
      border:1px solid rgba(15,23,42,0.14);
      border-radius:18px;
      background:#000;
      opacity:1;
      pointer-events:auto;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
  
    .ratio{
      position:relative;
      width:100%;
      aspect-ratio:16/9;
    }
  
    #player{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
    }
  
    .screen{ display:none; width:100%; }
    .screen.on{
      display:grid;
      gap:var(--gap);
    }
  
    /* ì‹œì‘ í™”ë©´ */
    .startBox{
      display:grid;
      gap:16px;
      place-items:center;
      min-height:clamp(320px, 40vw, 420px);
      text-align:center;
    }
  
    .bigText{
      font-size:clamp(18px, 2.6vw, 28px);
      font-weight:950;
      letter-spacing:-0.3px;
    }
  
    .smallText{
      font-size:var(--textS);
      font-weight:850;
      text-align:center;
      line-height:1.55;
      color:var(--muted);
    }
  
    .nickInput{
      width:min(420px, 92%);
      height:var(--inputH);
      border:1px solid var(--line);
      border-radius:18px;
      font-size:var(--textS);
      padding:0 14px;
      outline:none;
      text-align:center;
      background:#fff;
      color:var(--text);
      font-weight:850;
      transition: box-shadow 140ms ease, border-color 140ms ease;
    }
  
    .nickInput:focus{
      border-color: rgba(0,171,192,0.45);
      box-shadow: 0 0 0 4px rgba(0,171,192,0.18);
    }
  
    .startBtn{
      width:min(280px, 82%);
      height:clamp(54px, 6.8vw, 62px);
      border:0;
      border-radius:18px;
      background: linear-gradient(180deg, #6d58a0, var(--accent));
      color:#fff;
      font-weight:950;
      font-size:clamp(16px, 2vw, 18px);
      cursor:pointer;
      box-shadow: 0 16px 30px rgba(95,75,139,0.28);
      transition: transform 140ms ease, box-shadow 140ms ease;
    }
  
    .startBtn:hover{
      transform: translateY(-2px);
      box-shadow: 0 20px 36px rgba(95,75,139,0.35);
    }
  
    .startBtn:disabled{
      opacity:0.55;
      cursor:not-allowed;
      box-shadow:none;
    }
  
    /* ë©”ì¸ìœ¼ë¡œ(ìŠ¤íƒ€íŠ¸ í™”ë©´) ë¼ì´íŠ¸ ìŠ¤íƒ€ì¼ */
    #homeBtn.startBtn{
      background:#fff;
      color:var(--text);
      border:1px solid var(--line);
      box-shadow: 0 10px 18px rgba(2,6,23,0.08);
    }
  
    .groupPick{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }
  
    .groupBtn{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px 14px;
      font-weight:950;
      cursor:pointer;
      background:#fff;
      color:var(--text);
      font-size:var(--textS);
      transition: transform 140ms ease, box-shadow 140ms ease, background 140ms ease;
      box-shadow: 0 10px 18px rgba(2,6,23,0.06);
    }
  
    .groupBtn:hover{
      transform: translateY(-1px);
      box-shadow: 0 14px 22px rgba(2,6,23,0.10);
    }
  
    .groupBtn.on{
      background: rgba(0,171,192,0.10);
      border-color: rgba(0,171,192,0.45);
      box-shadow: 0 14px 22px rgba(0,171,192,0.10);
    }
  
    /* âœ… ê²Œì„ì˜¤ë²„ + ë­í‚¹ */
    .gameOverBox{
      display:grid;
      gap:14px;
      place-items:center;
      min-height:clamp(320px, 40vw, 420px);
      text-align:center;
    }
  
    .rankPanel{
      width:min(560px, 92%);
      border:1px solid var(--line);
      border-radius:18px;
      background:#fff;
      padding:14px;
      text-align:left;
      box-shadow: 0 12px 22px rgba(2,6,23,0.08);
    }
  
    .rankTitle{
      font-size:var(--textS);
      font-weight:950;
      margin-bottom:10px;
      color:var(--text);
    }
  
    .rankList{
      display:grid;
      gap:8px;
      font-size:var(--textS);
      font-weight:900;
      white-space:pre-line;
      color:var(--text);
    }
  
    .rankLine{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-radius:14px;
      border:1px dashed rgba(15,23,42,0.16);
      background:#fff;
    }
  
    .rankLeft{
      display:flex;
      gap:10px;
      align-items:center;
      min-width:0;
    }
  
    .rankNum{
      width:56px;
      text-align:right;
      font-weight:950;
      color:var(--muted);
      flex:0 0 auto;
    }
  
    .rankName{
      font-weight:950;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:240px;
    }
  
    .rankRight{
      font-weight:950;
      color:var(--muted);
      opacity:0.95;
      flex:0 0 auto;
    }
  
    @media (max-width: 520px){
      .groupPick{
        display:grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap:10px;
        width:min(360px, 92%);
        margin:0 auto;
      }
  
      .groupBtn{
        width:100%;
        padding:12px 0;
        text-align:center;
        border-radius:16px;
      }
  
      .rankName{ max-width:140px; }
    }
  
    @media (prefers-reduced-motion: reduce){
      .startBtn, .enterBtn, .groupBtn, .bigBtn, .nextBtn, .mvBtn{
        transition:none;
      }
    }
  </style>

</head>

<body>
  <div class="wrap">

    <div id="startScreen" class="screen on">
      <div class="panel now">
        <div>ì±Œë¦°ì§€ ëª¨ë“œ</div>
      </div>

      <div class="panel startBox">
        <div class="bigText">ê²Œì„ ì„¤ëª…</div>

        <div class="smallText">
          ì‹œê°„ ì œí•œ 6ì´ˆ ë™ì•ˆ 1ì´ˆ ë“£ê³  ë…¸ë˜ë¥¼ ë§ì¶”ë©´ ë©ë‹ˆë‹¤<br />
          ìƒëª…ì€ 3ê°œì´ë©°, ë‹¤ì‹œ ë“£ê¸°ëŠ” ê³¡ ë‹¹ 1íšŒì…ë‹ˆë‹¤<br />
          ë‹¤ì‹œ ë“£ê¸°ëŠ” ì‹œê°„ ì œí•œ ì•ˆì— ì‚¬ìš©í•´ì•¼ ì ìš©ë©ë‹ˆë‹¤<br />
          ë²”ìœ„ë¥¼ ì„ íƒí•œ ë’¤ ê²Œì„ ì‹œì‘ì„ ëˆ„ë¥´ì„¸ìš”<br />
        </div>

        <div class="bigText">ì…ë ¥ ê°€ì´ë“œ</div>
        <div class="smallText">
          ëŒ€ì†Œë¬¸ì, ë„ì–´ì“°ê¸° ìƒê´€ì—†ìŠµë‹ˆë‹¤<br />
          ì˜ì–´ ì œëª©ì„ í•œê¸€ë¡œ ì ì–´ë„ ë©ë‹ˆë‹¤ (ex. LOL -> ë¡¤)<br />
          ì¼ë¶€ ê³¡ì€ ì¤„ì„ë§ì´ ìˆìŠµë‹ˆë‹¤(ex. ì˜¤ìš°, ì§€ë§Œê°‘, ìš°ë‹¤ê³„)
        </div>

        <div class="bigText">ë‹‰ë„¤ì„ ì…ë ¥</div>
        <input id="nickname" class="nickInput" placeholder="ë‹‰ë„¤ì„" maxlength="20" autocomplete="off" />

        <div class="bigText">ë²”ìœ„ë¥¼ ì„ íƒí•˜ì„¸ìš”</div>
        <div id="groupPick" class="groupPick" aria-label="group pick">
          <button type="button" class="groupBtn on" data-key="gfriend">GFRIEND</button>
          <button type="button" class="groupBtn" data-key="yerin">YERIN</button>
          <button type="button" class="groupBtn" data-key="yuju">YUJU</button>
          <button type="button" class="groupBtn" data-key="viviz">VIVIZ</button>
        </div>

        <button id="startBtn" class="startBtn">ê²Œì„ ì‹œì‘</button>
        <button id="homeBtn" class="startBtn">ë©”ì¸ìœ¼ë¡œ</button>

        <div id="msgStart" class="msg info"></div>
      </div>
    </div>

    <div id="gameScreen" class="screen">
      <div class="panel now">
        <div id="nowText">Now Playing</div>
      </div>

      <div class="panel main">
        <div class="row">0ì´ˆë¶€í„° 1ì´ˆê°„ ë“¤ë ¤ë“œë¦½ë‹ˆë‹¤</div>

        <div class="livesRow" id="livesRow" aria-label="lives"></div>

        <div class="timeRow">
          ë‚¨ì€ ì‹œê°„ <span id="timeLeft">6</span>s
        </div>

        <div class="answerArea">
          <input id="answer" class="answerInput" placeholder="ì…ë ¥í•˜ì„¸ìš”" autocomplete="off" />
          <button id="enterBtn" class="enterBtn">Enter</button>
        </div>

        <div class="statRow">
          <div>ì •ë‹µ: <span id="score">0/0</span></div>
          <div>ë‹¤ì‹œë“£ê¸°: <span id="replayLeft">(1)</span></div>
        </div>

        <div class="bigBtns">
          <button id="revealBtn" class="bigBtn">ì •ë‹µ ê³µê°œ</button>
          <button id="replayBtn" class="bigBtn">ë‹¤ì‹œë“£ê¸°</button>
        </div>

        <div class="mvArea">
          <div class="mvLabel">M V</div>
          <button id="mvBtn" class="mvBtn">on</button>
        </div>

        <div class="footerRow">
          <button id="nextBtn" class="nextBtn" disabled>ë‹¤ìŒ</button>
        </div>

        <div id="msg" class="msg info"></div>

        <div id="playerShell" class="playerAudioOnly">
          <div class="ratio">
            <div id="player"></div>
          </div>
        </div>
      </div>
    </div>

    <div id="gameOverScreen" class="screen">
      <div class="panel now">
        <div>Game Over</div>
      </div>
      <div class="panel gameOverBox">
        <div id="gameOverText" class="bigText"></div>
        <div class="rankPanel">
          <div class="rankTitle">ë­í‚¹ TOP 20</div>
          <div id="rankBox" class="rankList"></div>
        </div>
        <button id="restartBtn" class="startBtn">ì²˜ìŒìœ¼ë¡œ</button>
      </div>
    </div>

  </div>

  <script>
    const STORAGE_BLOCK = "gfriend_blocked_videoids_v5"

    const BLOCK_TTL_1 = 7 * 24 * 60 * 60 * 1000
    const BLOCK_TTL_2 = 30 * 24 * 60 * 60 * 1000

    const FIXED_START_SEC = 0
    const FIXED_DUR_SEC = 1.5
    const ANSWER_LIMIT_SEC = 6

    const GROUPS = {
      gfriend: { label: "GFRIEND", path: "./assets/songs/gfriend.json" },
      yerin:  { label: "YERIN",  path: "./assets/songs/yerin.json"  },
      yuju:   { label: "YUJU",   path: "./assets/songs/yuju.json"   },
      viviz:  { label: "VIVIZ",  path: "./assets/songs/viviz.json"  },
    }

    const el = {
      startScreen: document.getElementById("startScreen"),
      gameScreen: document.getElementById("gameScreen"),
      gameOverScreen: document.getElementById("gameOverScreen"),
      rankBox: document.getElementById("rankBox"),

      nickname: document.getElementById("nickname"),
      startBtn: document.getElementById("startBtn"),
      homeBtn: document.getElementById("homeBtn"),
      msgStart: document.getElementById("msgStart"),

      restartBtn: document.getElementById("restartBtn"),
      gameOverText: document.getElementById("gameOverText"),

      nowText: document.getElementById("nowText"),
      livesRow: document.getElementById("livesRow"),
      timeLeft: document.getElementById("timeLeft"),

      answer: document.getElementById("answer"),
      enterBtn: document.getElementById("enterBtn"),

      score: document.getElementById("score"),
      replayLeft: document.getElementById("replayLeft"),

      revealBtn: document.getElementById("revealBtn"),
      replayBtn: document.getElementById("replayBtn"),
      mvBtn: document.getElementById("mvBtn"),
      nextBtn: document.getElementById("nextBtn"),
      msg: document.getElementById("msg"),
      playerShell: document.getElementById("playerShell"),
    }

    function setMsg(text, kind){
      if(el.msg){
        el.msg.className = "msg " + kind
        el.msg.textContent = text
      }
      if(el.msgStart){
        el.msgStart.className = "msg " + kind
        el.msgStart.textContent = text
      }
    }

    function delay(ms){
      return new Promise(r => setTimeout(r, ms))
    }

    function uniq(arr){
      return Array.from(new Set((arr || []).filter(Boolean)))
    }

    function shuffle(a){
      const b = [...a]
      for(let i=b.length-1;i>0;i--){
        const j = Math.floor(Math.random() * (i+1))
        ;[b[i], b[j]] = [b[j], b[i]]
      }
      return b
    }

    function normalize(s){
      return String(s || "")
        .toLowerCase()
        .replace(/\s+/g, "")
        .replace(/[^0-9a-zê°€-í£]/g, "")
    }

    function showScreen(which){
      el.startScreen.className = "screen"
      el.gameScreen.className = "screen"
      el.gameOverScreen.className = "screen"
      which.className = "screen on"
    }

    function nowMs(){ return Date.now() }

    function isExpired(entry){
      return !entry || typeof entry.until !== "number" || entry.until <= nowMs()
    }

    function cleanBlocked(obj){
      const out = {}
      for(const [vid, entry] of Object.entries(obj || {})){
        if(!isExpired(entry)) out[vid] = entry
      }
      return out
    }

    function loadBlocked(){
      try{
        const raw = localStorage.getItem(STORAGE_BLOCK)
        if(!raw) return {}
        const obj = JSON.parse(raw)
        if(!obj || typeof obj !== "object") return {}
        return cleanBlocked(obj)
      } catch {
        return {}
      }
    }

    function saveBlocked(obj){
      try{
        const cleaned = cleanBlocked(obj)
        localStorage.setItem(STORAGE_BLOCK, JSON.stringify(cleaned))
      } catch {}
    }

    let blocked = loadBlocked()
    saveBlocked(blocked)

    function isBlockedVideoId(videoId){
      const entry = blocked[videoId]
      if(!entry) return false
      if(isExpired(entry)){
        delete blocked[videoId]
        saveBlocked(blocked)
        return false
      }
      return true
    }

    function hideVideo(){
      el.playerShell.className = "playerAudioOnly"
    }

    function showVideo(){
      el.playerShell.className = "playerShow"
    }

    let mvOn = true
    let revealed = false
    let revealedLocked = false

    function applyVideoVisibility(){
      if(revealed && mvOn) showVideo()
      else hideVideo()
    }

    function toggleMv(){
      mvOn = !mvOn
      if(mvOn){
        el.mvBtn.classList.remove("off")
        el.mvBtn.textContent = "on"
      } else {
        el.mvBtn.classList.add("off")
        el.mvBtn.textContent = "off"
      }
      applyVideoVisibility()
    }

    let nickname = ""
    let selectedGroupKeys = new Set(["gfriend"])

    let songs = []
    let list = []
    let idx = -1
    let activeVideoId = null

    let correctCount = 0
    let totalCount = 0

    const MAX_LIVES = 3
    let livesLeft = MAX_LIVES

    let replayLeft = 1
    let roundEnded = false
    let gameEnded = false

    function updateScore(){
      el.score.textContent = String(correctCount) + "/" + String(totalCount)
    }

    function renderLives(){
      const parts = []
      for(let i=0;i<MAX_LIVES;i++){
        const alive = i < livesLeft
        parts.push(alive ? "â¤ï¸" : "ğŸ–¤")
      }
      el.livesRow.textContent = parts.join("")
    }

    function updateReplayLeft(){
      el.replayLeft.textContent = String(replayLeft) + "ë²ˆ"
      el.replayBtn.disabled = replayLeft <= 0 || revealedLocked || roundEnded || gameEnded
    }

    let player = null
    let ready = false
    let lastErrorCode = null

    let stopTimer = null
    let countTimer = null
    let answerTimer = null

    let actionToken = 0
    let answerLeft = ANSWER_LIMIT_SEC

    const YT_STATE = { PLAYING: 1 }

    function stopAnswerTimer(){
      if(answerTimer){
        clearInterval(answerTimer)
        answerTimer = null
      }
    }

    function setAnswerLeft(n){
      answerLeft = n
      el.timeLeft.textContent = String(answerLeft)
    }

    function startAnswerTimer(seconds){
      stopAnswerTimer()
      setAnswerLeft(seconds)

      answerTimer = setInterval(() => {
        if(gameEnded || roundEnded){
          stopAnswerTimer()
          return
        }

        answerLeft -= 1
        if(answerLeft <= 0){
          setAnswerLeft(0)
          stopAnswerTimer()
          const s = list[idx]
          endRound(false, s ? s.title : "", true, "ì‹œê°„ ì´ˆê³¼")
          return
        }

        el.timeLeft.textContent = String(answerLeft)
      }, 1000)
    }

    function stopTimers(){
      if(stopTimer){ clearTimeout(stopTimer); stopTimer = null }
      if(countTimer){ clearInterval(countTimer); countTimer = null }
      stopAnswerTimer()
    }

    function nextToken(){
      actionToken += 1
      return actionToken
    }

    function isCurrentToken(t){
      return t === actionToken
    }

    function hardStopMute(){
      stopTimers()
      if(player){
        try{ player.mute() } catch {}
        try{ player.setVolume(0) } catch {}
        try{ player.pauseVideo() } catch {}
        try{ player.stopVideo() } catch {}
      }
    }

    function markBlockedIfEmbed(code){
      if(!activeVideoId) return
      if(code !== 101 && code !== 150) return

      const vid = activeVideoId
      const prev = blocked[vid] || { count: 0, until: 0, lastCode: null }

      const nextCount = (typeof prev.count === "number" ? prev.count : 0) + 1
      const ttl = nextCount >= 2 ? BLOCK_TTL_2 : BLOCK_TTL_1

      blocked[vid] = {
        count: nextCount,
        until: nowMs() + ttl,
        lastCode: code
      }

      saveBlocked(blocked)
    }

    function pickPlayableVideoId(song){
      const ids = uniq(song.videoIds || [])
      for(const id of ids){
        if(!isBlockedVideoId(id)) return id
      }
      return null
    }

    function pickNextSong(){
      if(list.length === 0){
        list = shuffle(songs)
        idx = -1
      }

      let safety = 0
      while(safety < songs.length + 3){
        idx += 1
        if(idx >= list.length){
          list = shuffle(songs)
          idx = 0
        }

        const s = list[idx]
        const vid = pickPlayableVideoId(s)
        if(vid){
          activeVideoId = vid
          return true
        }

        safety += 1
      }
      return false
    }

    function resetRoundUI(){
      roundEnded = false
      revealed = false
      revealedLocked = false
      replayLeft = 1

      el.answer.value = ""
      el.answer.disabled = false
      el.enterBtn.disabled = false

      el.nextBtn.disabled = true

      applyVideoVisibility()
      updateReplayLeft()
      setAnswerLeft(ANSWER_LIMIT_SEC)

      setMsg("", "info")
      el.nowText.textContent = "Now Playing"
    }

    function endRound(isCorrect, answerTitle, consumeLife, reasonText){
      if(roundEnded) return
      roundEnded = true
      revealedLocked = true

      stopAnswerTimer()

      totalCount += 1
      if(isCorrect) correctCount += 1
      updateScore()

      el.answer.disabled = true
      el.enterBtn.disabled = true
      el.replayBtn.disabled = true
      el.nextBtn.disabled = false

      if(isCorrect){
        el.nowText.textContent = "ì •ë‹µ"
        setMsg("ì •ë‹µ", "ok")
      } else {
        el.nowText.textContent = "ì˜¤ë‹µ"
        if(reasonText){
          setMsg(reasonText + "\nì •ë‹µ: " + answerTitle, "bad")
        } else {
          setMsg("ì •ë‹µ: " + answerTitle, "bad")
        }
      }

      if(consumeLife){
        livesLeft = Math.max(0, livesLeft - 1)
        renderLives()
        if(livesLeft <= 0){
          gameEnded = true
          el.nextBtn.disabled = true
          ;(async () => {
            await delay(500)
            gameOver()
          })()
        }
      }
    }

    async function gameOver(){
      hardStopMute()
    
      const text =
        nickname + "ë‹˜ì˜ ì ìˆ˜ëŠ” " +
        String(correctCount) + "/" + String(totalCount) + "ì…ë‹ˆë‹¤"
    
      el.gameOverText.textContent = text
      showScreen(el.gameOverScreen)
    
      el.rankBox.innerHTML = `
        <div class="rankLine">
          <div class="rankLeft">
            <span class="rankNum">-</span>
            <span class="rankName">ë­í‚¹ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘</span>
          </div>
          <div class="rankRight"></div>
        </div>
      `
    
      await submitScore()
    
      const list = await loadRanking()
      renderRanking(list)
    }

    async function waitForPlayingOrError(token, timeoutMs){
      const started = Date.now()
      while(Date.now() - started < timeoutMs){
        if(!isCurrentToken(token)) return { ok:false, reason:"stale" }
        if(lastErrorCode !== null) return { ok:false, reason:"error", code:lastErrorCode }

        let st = null
        try{ st = player.getPlayerState() } catch {}

        if(st === YT_STATE.PLAYING) return { ok:true }
        await delay(80)
      }
      return { ok:false, reason:"timeout" }
    }

    async function startMutedNow(token, videoId){
      if(!isCurrentToken(token)) return { ok:false, reason:"stale" }
      lastErrorCode = null

      try{
        player.mute()
        player.setVolume(0)
      } catch {}

      try{
        player.loadVideoById({ videoId, startSeconds: 0 })
        player.playVideo()
      } catch {
        return { ok:false, reason:"exception" }
      }

      for(let attempt = 0; attempt < 3; attempt++){
        const r = await waitForPlayingOrError(token, 1300)
        if(r.ok) return { ok:true }
        if(r.reason === "error") return r
        if(!isCurrentToken(token)) return { ok:false, reason:"stale" }

        try{
          player.loadVideoById({ videoId, startSeconds: 0 })
          player.playVideo()
        } catch {}
        await delay(160)
      }

      return { ok:false, reason:"timeout" }
    }

    async function seekAndUnmuteClip(token, startSec, durSec){
      if(!isCurrentToken(token)) return { ok:false, reason:"stale" }
      lastErrorCode = null

      try{
        player.mute()
        player.setVolume(0)
      } catch {}

      try{
        player.seekTo(startSec, true)
        player.playVideo()
      } catch {}

      const r = await waitForPlayingOrError(token, 1200)
      if(!r.ok) return r

      try{
        player.unMute()
        player.setVolume(100)
      } catch {}

      await delay(120)
      if(!isCurrentToken(token)) return { ok:false, reason:"stale" }
      try{
        player.unMute()
        player.setVolume(100)
      } catch {}

      if(stopTimer){ clearTimeout(stopTimer); stopTimer = null }
      stopTimer = setTimeout(() => {
        try{
          player.mute()
          player.setVolume(0)
          player.pauseVideo()
        } catch {}
        setMsg("ì •ë‹µì„ ì…ë ¥í•˜ì„¸ìš”", "info")
      }, durSec * 1000)

      return { ok:true }
    }

    function startCountdownToPlay(token, seconds, onDone){
      stopTimers()
      let n = Math.max(1, Math.min(30, Number(seconds) || 3))
      el.nowText.textContent = String(n) + "ì´ˆ í›„ ì¬ìƒ"
      countTimer = setInterval(() => {
        if(!isCurrentToken(token)){
          clearInterval(countTimer)
          countTimer = null
          el.nowText.textContent = "Now Playing"
          return
        }
        n -= 1
        if(n <= 0){
          clearInterval(countTimer)
          countTimer = null
          onDone()
          return
        }
        el.nowText.textContent = String(n) + "ì´ˆ í›„ ì¬ìƒ"
      }, 1000)
    }

    async function startNextFlow(){
      if(gameEnded) return
      if(!ready){
        setMsg("í”Œë ˆì´ì–´ ì´ˆê¸°í™” ì¤‘", "bad")
        return
      }
      if(songs.length === 0){
        setMsg("ë°ì´í„° ë¡œë”© ì¤‘", "info")
        return
      }

      const token = nextToken()

      hardStopMute()
      resetRoundUI()

      const ok = pickNextSong()
      if(!ok){
        setMsg("ì¬ìƒ ê°€ëŠ¥í•œ ì˜ìƒì´ ì—†ìŒ", "bad")
        return
      }

      try{
        player.mute()
        player.setVolume(0)
        player.stopVideo()
      } catch {}

      const r1 = await startMutedNow(token, activeVideoId)
      if(!isCurrentToken(token)) return

      if(!r1.ok){
        if(r1.reason === "error"){
          markBlockedIfEmbed(r1.code)
          setMsg("ì¬ìƒ ì‹¤íŒ¨ë¡œ ë‹¤ìŒ ë¬¸ì œë¡œ ì´ë™", "bad")
          await delay(220)
          if(isCurrentToken(token)) startNextFlow()
          return
        }
        setMsg("ì¬ìƒ ì‹œì‘ ì‹¤íŒ¨ë¡œ ë‹¤ìŒ ë¬¸ì œë¡œ ì´ë™", "bad")
        await delay(220)
        if(isCurrentToken(token)) startNextFlow()
        return
      }

      startCountdownToPlay(token, 3, async () => {
        if(!isCurrentToken(token)) return
        const r2 = await seekAndUnmuteClip(token, FIXED_START_SEC, FIXED_DUR_SEC)
        if(!isCurrentToken(token)) return
        if(!r2.ok){
          if(r2.reason === "error") markBlockedIfEmbed(r2.code)
          setMsg("í´ë¦½ ì¬ìƒ ì‹¤íŒ¨ë¡œ ë‹¤ìŒ ë¬¸ì œë¡œ ì´ë™", "bad")
          await delay(250)
          if(isCurrentToken(token)) startNextFlow()
          return
        }
        el.nowText.textContent = "Now Playing"
        startAnswerTimer(ANSWER_LIMIT_SEC)
      })
    }

    async function replay(){
      if(gameEnded) return
      if(roundEnded || revealedLocked){
        setMsg("ì´ ë¬¸ì œëŠ” ë‹¤ì‹œë“£ê¸° ë¶ˆê°€", "bad")
        return
      }
      if(replayLeft <= 0){
        setMsg("ë‹¤ì‹œë“£ê¸° íšŸìˆ˜ ì—†ìŒ", "bad")
        return
      }
      if(!ready){
        setMsg("í”Œë ˆì´ì–´ ì´ˆê¸°í™” ì¤‘", "bad")
        return
      }

      const token = nextToken()
      stopTimers()

      revealed = false
      applyVideoVisibility()

      setMsg("ë‹¤ì‹œ ë“£ê¸°", "info")

      const r1 = await startMutedNow(token, activeVideoId)
      if(!isCurrentToken(token)) return

      if(!r1.ok){
        if(r1.reason === "error"){
          markBlockedIfEmbed(r1.code)
          setMsg("ì„ë² ë“œ ì œí•œ ë˜ëŠ” ì¬ìƒ ì‹¤íŒ¨, ë‹¤ìŒ ë¬¸ì œë¡œ ì´ë™", "bad")
          await delay(250)
          if(isCurrentToken(token)) startNextFlow()
          return
        }
        setMsg("ì¬ìƒ ì‹œì‘ ì‹¤íŒ¨", "bad")
        return
      }

      replayLeft -= 1
      updateReplayLeft()

      const r2 = await seekAndUnmuteClip(token, FIXED_START_SEC, FIXED_DUR_SEC)
      if(!isCurrentToken(token)) return

      if(!r2.ok){
        replayLeft += 1
        updateReplayLeft()
        if(r2.reason === "error"){
          markBlockedIfEmbed(r2.code)
          setMsg("í´ë¦½ ì¬ìƒ ì‹¤íŒ¨, ë‹¤ìŒ ë¬¸ì œë¡œ ì´ë™", "bad")
          await delay(250)
          if(isCurrentToken(token)) startNextFlow()
          return
        }
        setMsg("í´ë¦½ ì¬ìƒ ì‹¤íŒ¨", "bad")
        return
      }

      el.nowText.textContent = "Now Playing"
      startAnswerTimer(ANSWER_LIMIT_SEC)
    }

    function reveal(){
      if(gameEnded) return
      if(idx < 0){
        setMsg("ê²Œì„ ì‹œì‘ í•„ìš”", "info")
        return
      }
      if(roundEnded) return

      const token = nextToken()
      stopTimers()

      revealed = true
      revealedLocked = true

      el.replayBtn.disabled = true
      el.enterBtn.disabled = true
      el.answer.disabled = true

      applyVideoVisibility()

      const s = list[idx]
      endRound(false, s.title, true, "ì •ë‹µ ê³µê°œ")

      if(mvOn && activeVideoId && ready && !gameEnded){
        lastErrorCode = null
        try{
          player.unMute()
          player.setVolume(100)
          player.loadVideoById({ videoId: activeVideoId, startSeconds: 0 })
          player.playVideo()
        } catch {}

        ;(async () => {
          const r = await waitForPlayingOrError(token, 1500)
          if(!isCurrentToken(token)) return
          if(!r.ok && r.reason === "error"){
            markBlockedIfEmbed(r.code)
            setMsg("MV ì„ë² ë“œ ì œí•œ", "bad")
          }
        })()
      }
    }

    function check(){
      if(gameEnded) return
      if(idx < 0){
        setMsg("ê²Œì„ ì‹œì‘ í•„ìš”", "info")
        return
      }
      if(roundEnded){
        setMsg("ë‹¤ìŒ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”", "info")
        return
      }

      const v = el.answer.value
      const s = list[idx]

      if(!v || !v.trim()){
        setMsg("ì •ë‹µì„ ì…ë ¥í•˜ì„¸ìš”", "bad")
        return
      }

      const ok = s.answers.some(a => normalize(a) === normalize(v))
      if(ok){
        endRound(true, s.title, false, "")
        return
      }

      endRound(false, s.title, true, "ì˜¤ë‹µ")
    }

    async function loadSongsFromSelectedGroups(){
      const keys = Array.from(selectedGroupKeys).filter(k => GROUPS[k])
      if(keys.length === 0){
        setMsg("ë²”ìœ„ë¥¼ 1ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”", "bad")
        return false
      }

      setMsg("ë°ì´í„° ë¡œë”© ì¤‘", "info")
      el.startBtn.disabled = true

      try{
        const results = await Promise.all(keys.map(async (k) => {
          const g = GROUPS[k]
          const res = await fetch(g.path, { cache: "no-store" })
          if(!res.ok) return { key:k, ok:false, songs:[] }
          const data = await res.json()
          const loaded = (data && data.songs) ? data.songs : []
          const mapped = loaded.map(s => ({
            title: s.title,
            answers: Array.isArray(s.answers) ? uniq(s.answers) : [],
            videoIds: s.videoId ? [s.videoId] : []
          }))
          return { key:k, ok:true, songs:mapped }
        }))

        const merged = []
        for(const r of results){
          merged.push(...(r.songs || []))
        }

        songs = merged
        list = []
        idx = -1
        activeVideoId = null

        if(songs.length === 0){
          setMsg("ê³¡ ë°ì´í„°ê°€ ë¹„ì–´ìˆìŒ", "bad")
          el.startBtn.disabled = false
          return false
        }

        el.startBtn.disabled = false
        return true
      } catch {
        setMsg("ë°ì´í„° ë¡œë”© ì‹¤íŒ¨", "bad")
        el.startBtn.disabled = false
        return false
      }
    }

    async function startGame(){
      const raw = String(el.nickname.value || "").trim()
      if(!raw){
        setMsg("ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”", "bad")
        return
      }

      const keys = Array.from(selectedGroupKeys).filter(k => GROUPS[k])
      if(keys.length === 0){
        setMsg("ë²”ìœ„ë¥¼ 1ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”", "bad")
        return
      }

      nickname = raw

      const ok = await loadSongsFromSelectedGroups()
      if(!ok) return

      correctCount = 0
      totalCount = 0
      livesLeft = MAX_LIVES
      replayLeft = 1
      roundEnded = false
      revealedLocked = false
      gameEnded = false

      updateScore()
      renderLives()
      updateReplayLeft()
      setAnswerLeft(ANSWER_LIMIT_SEC)

      el.nowText.textContent = "Now Playing"
      el.answer.value = ""
      el.answer.disabled = false
      el.enterBtn.disabled = false

      showScreen(el.gameScreen)
      setMsg("ë‹¤ìŒ ë¬¸ì œ ì¤€ë¹„", "info")

      startNextFlow()
    }

    function resetToStart(){
      hardStopMute()

      nickname = ""
      el.nickname.value = ""

      songs = []
      list = []
      idx = -1
      activeVideoId = null

      correctCount = 0
      totalCount = 0
      livesLeft = MAX_LIVES
      replayLeft = 1
      roundEnded = false
      revealedLocked = false
      gameEnded = false

      updateScore()
      renderLives()
      updateReplayLeft()
      setAnswerLeft(ANSWER_LIMIT_SEC)

      showScreen(el.startScreen)
      setMsg("", "info")
    }

    async function submitScore(){
      try{
        await fetch("/api/score", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            nickname,
            correct: correctCount,
            total: totalCount
          })
        })
      } catch {}
    }

    async function loadRanking(){
      try{
        const res = await fetch("/api/ranking?limit=20")
        const json = await res.json()
        if(!json || !json.ok) return []
        return Array.isArray(json.data) ? json.data : []
      } catch {
        return []
      }
    }

    function escapeHtml(s){
      return String(s || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;")
    }
    
    function renderRanking(list){
      if(!el.rankBox) return
    
      if(!list || list.length === 0){
        el.rankBox.innerHTML = `<div class="rankLine">
          <div class="rankLeft">
            <span class="rankNum">-</span>
            <span class="rankName">ë­í‚¹ ì—†ìŒ</span>
          </div>
        </div>`
        return
      }
    
      const html = list.map(r => {
        const lineLeft = `${r.rank}ìœ„`
        const name = `${escapeHtml(r.nickname)}ë‹˜`
        const right = `${r.score}ì  (${r.correct}/${r.total})`
    
        return `
          <div class="rankLine">
            <div class="rankLeft">
              <span class="rankNum">${lineLeft}</span>
              <span class="rankName">${name}</span>
            </div>
            <div class="rankRight">${right}</div>
          </div>
        `
      }).join("")
    
      el.rankBox.innerHTML = html
    }

    function onYouTubeIframeAPIReady(){
      player = new YT.Player("player", {
        videoId: "",
        playerVars: {
          playsinline: 1,
          rel: 0,
          modestbranding: 1,
          controls: 1,
          origin: location.origin
        },
        events: {
          onReady: () => {
            ready = true
            hideVideo()
            try{
              player.mute()
              player.setVolume(0)
            } catch {}
          },
          onError: (e) => {
            const code = (e && typeof e.data !== "undefined") ? Number(e.data) : -1
            lastErrorCode = code
            markBlockedIfEmbed(code)
          }
        }
      })
    }
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady

    el.enterBtn.addEventListener("click", () => check())
    el.answer.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        e.preventDefault()
        check()
      }
    })

    el.replayBtn.addEventListener("click", () => replay())
    el.revealBtn.addEventListener("click", () => reveal())
    el.mvBtn.addEventListener("click", () => toggleMv())
    el.nextBtn.addEventListener("click", () => {
      if(gameEnded) return
      if(!roundEnded){
        setMsg("ì •ë‹µì„ ì…ë ¥í•˜ê±°ë‚˜ ì •ë‹µê³µê°œë¥¼ ëˆ„ë¥´ì„¸ìš”", "bad")
        return
      }
      startNextFlow()
    })

    el.startBtn.addEventListener("click", () => startGame())
    el.nickname.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        e.preventDefault()
        startGame()
      }
    })

    el.homeBtn.addEventListener("click", () => {
      hardStopMute()
      location.href = "./index.html"
    })

    el.restartBtn.addEventListener("click", () => resetToStart())

    window.addEventListener("DOMContentLoaded", () => {
      showScreen(el.startScreen)

      applyVideoVisibility()
      updateScore()
      renderLives()
      updateReplayLeft()
      setAnswerLeft(ANSWER_LIMIT_SEC)

      const groupPick = document.getElementById("groupPick")
      if(groupPick){
        groupPick.addEventListener("click", (e) => {
          const btn = e.target && e.target.closest ? e.target.closest(".groupBtn") : null
          if(!btn) return

          const key = String(btn.dataset.key || "")
          if(!GROUPS[key]) return

          if(btn.classList.contains("on")){
            if(selectedGroupKeys.size <= 1) return
            btn.classList.remove("on")
            selectedGroupKeys.delete(key)
          } else {
            btn.classList.add("on")
            selectedGroupKeys.add(key)
          }
        })
      }

      const tag = document.createElement("script")
      tag.src = "https://www.youtube.com/iframe_api"
      document.head.appendChild(tag)
    })
  </script>
</body>
</html>







